name: CI-CD Pipeline # Name of the workflow

# What events trigger the workflow
on:
  push:
      branches:
            - main
            - 'feature/*' # Pipeline will be triggered on any push to a branch starting with 'feature/'
  pull_request:
      branches:
            - main

  # Allows manual triggering of the workflow - for testing purposes
  workflow_dispatch:



# Jobs - tasks to run
# Each job contains a sequence of steps

jobs:
    build-and-push-image: # Building and Pushing the Docker image if either the docker file or requirements.txt change
        runs-on: ubuntu-latest
        steps:
          - name: Checkout code # Get the code from repository
            uses: actions/checkout@v4
          - name: Get changed_files # Get dockerfile and requirements change
            id: changed-files-build # Set an ID to reference later
            uses: tj-actions/changed-files@v45
            with:
              files: |
                      dockerfile
                      requirements.txt
          - name: Set up Docker Buildx # Rebuild the docker image
            if: steps.changed-files-build.outputs.any_changed == 'true'
            uses: docker/setup-buildx-action@v3
          
          # Login into Docker Hub (where image resides)
          - name: Login to Docker Hub
            if: steps.changed-files-build.outputs.any_changed == 'true'
            uses: docker/login-action@v3
            with:
              username: ${{ vars.DOCKERHUB_USERNAME }}
              password: ${{ secrets.DOCKERHUB_PASSWORD }}

          # Write the code to build and push docker image. 
          - name: Build and push Docker image
            if: steps.changed-files-build.outputs.any_changed == 'true' 
            run: |                                                       #github.sha acts as a unique identifier (equivelent to what was done with .env files previously)
                      docker buildx build --push \
                        --tag ${{ vars.DOCKERHUB_NAMESPACE }}/${{ vars.DOCKERHUB_REPOSITORY }}:latest \
                        --tag ${{ vars.DOCKERHUB_NAMESPACE }}/${{ vars.DOCKERHUB_REPOSITORY }}:${{ github.sha }}
                        . # Path to Dockerfile (build context)
  
    unit-and-integration-and-e2e-tests:
        runs-on: ubuntu-latest
        needs: build-and-push-image # dependecies (have the latest docker image job needs to run first)
        env: # Set environment variables from GitHub Secrets and Variables, adjust docker-compose.yaml to not use .env file
          AIRFLOW_WWW_USER_PASSWORD: ${{ secrets.AIRFLOW_WWW_USER_PASSWORD }}
          AIRFLOW_WWW_USER_USERNAME: ${{ secrets.AIRFLOW_WWW_USER_USERNAME }}
          API_KEY: ${{ secrets.API_KEY }}
          CELERY_BACKEND_NAME: ${{ secrets.CELERY_BACKEND_NAME }}
          CELERY_BACKEND_PASSWORD: ${{ secrets.CELERY_BACKEND_PASSWORD }}
          CELERY_BACKEND_USERNAME: ${{ secrets.CELERY_BACKEND_USERNAME }}
          ELT_DATABASE_NAME: ${{ secrets.ELT_DATABASE_NAME }}
          ELT_DATABASE_PASSWORD: ${{ secrets.ELT_DATABASE_PASSWORD }}
          ELT_DATABASE_USERNAME: ${{ secrets.ELT_DATABASE_USERNAME }}
          FERNET_KEY: ${{ secrets.FERNET_KEY }}
          METADATA_DATABASE_NAME: ${{ secrets.METADATA_DATABASE_NAME }}
          METADATA_DATABASE_PASSWORD: ${{ secrets.METADATA_DATABASE_PASSWORD }}
          METADATA_DATABASE_USERNAME: ${{ secrets.METADATA_DATABASE_USERNAME }}
          POSTGRES_USER: ${{ secrets.POSTGRES_CONN_USERNAME }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_CONN_PASSWORD }}
          POSTGRES_CONN_HOST: ${{ secrets.POSTGRES_CONN_HOST }}
          POSTGRES_CONN_PASSWORD: ${{ secrets.POSTGRES_CONN_PASSWORD }}
          POSTGRES_CONN_PORT: ${{ secrets.POSTGRES_CONN_PORT }}
          POSTGRES_CONN_USERNAME: ${{ secrets.POSTGRES_CONN_USERNAME }}
          AIRFLOW_UID: ${{ vars.AIRFLOW_UID }}
          CHANNEL_HANDLE: ${{ vars.CHANNEL_HANDLE }}
          DOCKERHUB_NAMESPACE: ${{ vars.DOCKERHUB_NAMESPACE }}
          DOCKERHUB_REPOSITORY: ${{ vars.DOCKERHUB_REPOSITORY }}
          DOCKERHUB_USERNAME: ${{ vars.DOCKERHUB_USERNAME }}
        steps:
          - name: Checkout code # Get the code from repository
            uses: actions/checkout@v4
          - name: Get changed_files # Get changes on dags, include (soda tests) and docker-compose.yaml
            id: changed-files-tests # Set an ID to reference later
            uses: tj-actions/changed-files@v45
            with:
              files: |
                      dags/**
                      include/**
                      docker-compose.yaml

            # Execution Order:
              # Docker compose up - bring all services up
              # CI Run the pytest command (to run all tests inside tests folder)
              # CD Run the airflow dags test command for each dag inside main.py (it executes the dags)
              # docker compose down
          - name: Set up Docker Compose
            if: steps.changed-files-tests.outputs.any_changed == 'true'
            run: docker compose up -d

          - name: Run Unit and Integration Tests
            if: steps.changed-files-tests.outputs.any_changed == 'true'
            run: docker exec -t airflow-worker sh -c "pytest tests/ -v"

          - name: Run End-to-End DAG Tests
            if: steps.changed-files-tests.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
            run: |
              DAG_NAMES=("produce_json" "update_db" "data_quality") # In production, consider extracting DAG names dynamically 
              for DAG in "${DAG_NAMES[@]}"; do 
                docker exec -t airflow-worker sh -c "airflow dags test $DAG"
              done
              
          - name: Tear down Docker Compose
            if: steps.changed-files-tests.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
            run: docker compose down 


              